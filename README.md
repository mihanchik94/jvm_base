Для исследования представлен следующий код:
```java
public class JvmComprehension {
    public static void main(String[] args) {  // 0
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    } // 8
    private static void printAll(Object o, int i, Integer ii) { // 4.1
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    } // 6.1
}
```
Необходимо описать, что происходит на каждой из строк с точки зрения JVM.
___
###Подготовительный этап

Сначала происходит подготовка работы JVM, которую можно разделить на несколько этапов:

**На первом этапе** происходит запуск JVM, выделение памяти для областей Stack, Heap и Metaspace и создаются ClassLoaders.

**На втором этапе** Application ClassLoader загружает байт-код нашего класса (в данном случае `JvmComprehension`). 
После этого осуществляется проверка, возможно ли исполнить загруженный байт-код на установленной версии JVM.
Далее проверяются классы, которые определены в полях и методах класса `JvmComprehension`, если данные классы есть,
они также подгружаются для корректной работы программы (в нашем случае это классы `Object`, `Integer`, `System`, `String`).
После всех проверок класс загружается в область памяти Metaspace и становится доступным интерпретатору.

**На третьем этапе** осуществляется запуск программы. Интерпретатор ищет "точку входа" (метод `main`) и начинает выполнение программы.

---
###Выполнение программы (разбор строк)

#### Строка 0: Запуск метода `main()`
- В Stack создается фрейм метода `main()`.
   - Если были переданы аргументы, то во фрейм добавляется ссылка `args` на массив `String[]` в Heap.

#### Строка 1: `int i = 1;`
- В фрейм `main()` добавляется значение `int i = 1`

#### Строка 2: `Object o = new Object();`
- В Heap создается `new Object()`
- В фрейм `main()` добавляется ссылка `Object o` на созданный `new Object()`

#### Строка 3: `Integer ii = 2;`
- Поскольку присваиваемое значение Integer входит в пул интов, мы получаем объект из пула интов
- В фрейм `main()` добавляется ссылка `Integer ii` (ссылается на значение из пула интов)

#### Строка 4: `printAll(o, i, ii);` 
- В Stack добавляются аргументы для вызова метода:
    - ссылка на `Object o`
    - значение 1 для int
    - ссылка на `Integer ii`

- Вызов метода `printAll([01:Object], 1:int, [02:Integer])` заберает из Stack аргументы и передает управление 
***Строке 4.1:*** `printAll(Object o, int i, Integer ii)`
- В Stack создается новый фрейм `printAll()`
- Добавляется ссылка для `Object o`
- Добавляется значение для `int i`
- Добавляется ссылка для `Integer ii`


#### Строка 5: `Integer uselessVar = 700;`
- Поскольку присваиваемое значение Integer не входит в пул интов, в Heap создется `new Integer(700)`
- В фрейм `printAll()` добавляется ссылка `Integer uselessVar` на созданный `new Integer(700)` (данный объект нигде не используется, 
поэтому он может быть одним из первых на очереди при проведении сборки мусора)

#### Строка 6: `System.out.println(o.toString() + i + ii);`
> Рассмотрим процесс конкатенации строк для версии Java 8.
- Подготовка к конкатенации:
  - в Heap создется `new StringBuilder()`
     - В фрейме создается ссылка для созданного `new StringBuilder()`
       - Получение `o.toString()`:
           -  Вызывается метод `toString()` для `Object o`, результат заносится в Heap.
           - Во фрейм помещается ссылка для String
           - Вызывается метод .append
       - Получение `i`:
           - Вызывается метод `String.valueOf(int)`, результат заносится в Heap.
           - В фрейм помещается ссылка для String
           - Вызывается метод .append
       - Получение `ii`:
           - Вызывается метод `toString()` для `Integer ii` результат заносится в Heap.
           - В фрейм помещается ссылка для String
           - Вызывается метод .append
     
- Вызывается метод `.toString()` для `StringBuilder()`  результат заносится в Heap.
- В фрейм помещается ссылка для String с результатом конкатенации.
- Получение ссылки на `System.out`
- Вызается метод `.println()`
- Текст выводится на экран. 

#### Строка 6.1: 
- Происходит завершение метода, удаляется фрейм `printAll()`, удаляются ссылки на объекты, удаляются значения. 
Объекты с удаленными ссылками будут удалены при проведении сборки мусора.

#### Строка 7: `System.out.println("finished");`
- Получение ссылки на `System.out`
- Если в пуле строк нет такой строки, то в Heap создается `new String("finished")`
- В фрейм помещается анонимная ссылка на строку
- Вызовается метод `.println()`
- Текст выводится на экран.

#### Строка 8: 
- Происходит завершение метода, удаляется фрейм `main()`, удаляются ссылки на объекты, удаляются значения. 
Объекты с удаленными ссылками будут удалены при проведении сборки мусора.

#### Результат:
- Поскольку все фреймы удалены, Stack пустой. JVM возвращает выделенную для работы память операционной системе, 
завершает потоки и возвращает код 0, что говорит об успешном завершении работы программы. 